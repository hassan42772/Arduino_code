 #include <WiFi.h>
#include <ESP_Mail_Client.h>
#include <ESP32Servo.h>

// WiFi and SMTP settings
#define WIFI_SSID "Rana Hassan"
#define WIFI_PASSWORD "Super1234$"
#define SMTP_server "smtp.gmail.com"
#define SMTP_Port 465
#define sender_email "workmailesp@gmail.com"
#define sender_password "zqfu qajz mbmr jufu"
#define Recipient_email "aqsafareed111@gmail.com"
#define Recipient_name "Aqsa"

// Dustbin ultrasonic sensor pins
#define trigPin 5
#define echoPin 18

// Hand detection ultrasonic sensor pins
#define trig2Pin 22
#define echo2Pin 15

// Servo pin
#define servoPin 2

// LED pins
#define RED_LED 17
#define YELLOW_LED 13
#define GREEN_LED 12

// Buzzer pin
#define BUZZER 4

// Thresholds
const int fullThreshold = 10;
const int halfThreshold = 20;

// Flags
bool fullEmailSent = false;
bool halfEmailSent = false;

// Timers
unsigned long lastBinCheckTime = 0;
const unsigned long binCheckInterval = 10000; // 10 sec
unsigned long lastLidOpenTime = 0;

// Bin reading variables
int binReadCount = 0;
int fullCount = 0;
int halfCount = 0;
unsigned long lastReadTime = 0;
const unsigned long readInterval = 1000; // 1 sec between each bin reading
bool readingInProgress = false;

// SMTP and Servo
SMTPSession smtp;
ESP_Mail_Session session;
Servo myServo;

// --- Distance measuring functions ---
long getDistance() {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  long duration = pulseIn(echoPin, HIGH, 30000);
  return duration * 0.034 / 2;
}

long getLidDistance() {
  digitalWrite(trig2Pin, LOW);
  delayMicroseconds(2);
  digitalWrite(trig2Pin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trig2Pin, LOW);
  long duration = pulseIn(echo2Pin, HIGH, 30000);
  return duration * 0.034 / 2;
}

// --- Buzzer beep ---
void beepBuzzer(int duration) {
  digitalWrite(BUZZER, HIGH);
  delay(duration);
  digitalWrite(BUZZER, LOW);
}

// --- Send Email ---
void sendEmail(String status) {
  SMTP_Message message;
  message.sender.name = "Smart Bin System";
  message.sender.email = sender_email;
  message.subject = "Dustbin Status Alert ðŸš¨";
  message.addRecipient(Recipient_name, Recipient_email);

  String statusColor = (status == "FULL") ? "#dc3545" : "#ffc107";

  String htmlMsg = "<div style=\"background-color:#f4f4f4;padding:20px;font-family:Arial,sans-serif;\">"
                   "<div style=\"max-width:600px;margin:auto;background:#ffffff;padding:20px;border-radius:10px;"
                   "box-shadow:0 0 10px rgba(0,0,0,0.1);\">"
                   "<h2 style=\"color:#333;text-align:center;\">ðŸš® Dustbin Alert Notification</h2>"
                   "<p style=\"font-size:16px;color:#555;\">Dear Team,</p>"
                   "<p style=\"font-size:16px;color:#555;\">The current dustbin status is:</p>"
                   "<div style=\"background-color:" + statusColor + ";color:#fff;padding:10px 15px;"
                   "display:inline-block;border-radius:25px;font-size:18px;font-weight:bold;\">" + status + "</div>"
                   "<p style=\"margin-top:20px;font-size:14px;color:#888;\">This is an automated message generated by your <b>Smart Bin monitoring system.</b></p>"
                   "<p style=\"font-size:12px;color:#ccc;text-align:center;margin-top:30px;\">&copy; 2025 Smart Bin System</p>"
                   "</div></div>";

  message.html.content = htmlMsg.c_str();
  message.html.charSet = "utf-8";
  message.html.transfer_encoding = Content_Transfer_Encoding::enc_7bit;
  message.text.content = "Dustbin status: " + status;

  if (!smtp.connect(&session)) {
    Serial.println("SMTP connection failed.");
    return;
  }

  if (!MailClient.sendMail(&smtp, &message)) {
    Serial.println("Error sending Email, " + smtp.errorReason());
  } else {
    Serial.println("Email sent successfully.");
  }
}

// --- LED status control ---
void showLEDStatus(String status) {
  if (status == "FULL") {
    digitalWrite(RED_LED, HIGH);
    digitalWrite(YELLOW_LED, LOW);
    digitalWrite(GREEN_LED, LOW);
  } else if (status == "HALF FULL") {
    digitalWrite(RED_LED, LOW);
    digitalWrite(YELLOW_LED, HIGH);
    digitalWrite(GREEN_LED, LOW);
  } else {
    digitalWrite(RED_LED, LOW);
    digitalWrite(YELLOW_LED, LOW);
    digitalWrite(GREEN_LED, HIGH);
  }
}

// --- Setup ---
void setup() {
  Serial.begin(115200);

  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
  pinMode(trig2Pin, OUTPUT);
  pinMode(echo2Pin, INPUT);

  pinMode(RED_LED, OUTPUT);
  pinMode(YELLOW_LED, OUTPUT);
  pinMode(GREEN_LED, OUTPUT);
  pinMode(BUZZER, OUTPUT);

  myServo.attach(servoPin);
  myServo.write(0); // Start with lid closed

  Serial.print("Connecting to WiFi...");
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  while (WiFi.status() != WL_CONNECTED) {
    delay(200);
    Serial.print(".");
  }
  Serial.println("\nWiFi connected.");

  smtp.debug(1);
  session.server.host_name = SMTP_server;
  session.server.port = SMTP_Port;
  session.login.email = sender_email;
  session.login.password = sender_password;
  session.login.user_domain = "";
}

// --- Main Loop ---
void loop() {
  static bool lidOpen = false;

  // âœ… Lid control: open while hand detected, close after hand is removed
  long lidDistance = getLidDistance();
  if (lidDistance > 0 && lidDistance <= 15) {
    if (!lidOpen) {
      Serial.println("Hand detected - opening lid");
      myServo.write(90);  // Open lid
      lidOpen = true;
    }
    lastLidOpenTime = millis();  // Reset timer while hand is still there
  } else {
    if (lidOpen && millis() - lastLidOpenTime > 1000) {
      Serial.println("Hand removed - closing lid");
      myServo.write(0);  // Close lid
      lidOpen = false;
    }
  }

  // âœ… Start bin check if time
  if (!readingInProgress && millis() - lastBinCheckTime >= binCheckInterval) {
    readingInProgress = true;
    binReadCount = 0;
    fullCount = 0;
    halfCount = 0;
    lastReadTime = millis();
    Serial.println("Starting dustbin level readings...");
  }

  // âœ… Perform bin readings non-blocking
  if (readingInProgress && millis() - lastReadTime >= readInterval) {
    lastReadTime = millis();
    long distance = getDistance();
    binReadCount++;

    Serial.print("Reading ");
    Serial.print(binReadCount);
    Serial.print(": ");
    Serial.print(distance);
    Serial.println(" cm");

    if (distance <= fullThreshold) fullCount++;
    else if (distance <= halfThreshold) halfCount++;

    if (binReadCount >= 5) {
      readingInProgress = false;
      lastBinCheckTime = millis();

      if (fullCount >= 5) {
        showLEDStatus("FULL");
        if (!fullEmailSent) {
          Serial.println("Dustbin is FULL! Sending email...");
          beepBuzzer(2000);
          sendEmail("FULL");
          fullEmailSent = true;
        } else {
          Serial.println("Dustbin still full. Email already sent.");
        }
        halfEmailSent = true;
      } else if (halfCount >= 5) {
        showLEDStatus("HALF FULL");
        if (!halfEmailSent) {
          Serial.println("Dustbin is HALF FULL! Sending email...");
          for (int i = 0; i < 3; i++) {
            beepBuzzer(500);
            delay(300);
          }
          sendEmail("HALF FULL");
          halfEmailSent = true;
        } else {
          Serial.println("Dustbin still half full. Email already sent.");
        }
        fullEmailSent = false;
      } else {
        showLEDStatus("EMPTY");
        digitalWrite(BUZZER, LOW);
        Serial.println("Dustbin is not full.");
        fullEmailSent = false;
        halfEmailSent = false;
      }
    }
  }
}
